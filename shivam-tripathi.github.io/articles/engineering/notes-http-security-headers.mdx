# Notes: Security Headers

HTTP security headers are a fundamental component of web security.

## [Attacks](https://owasp.org/www-community/attacks/)
- [Cross-site Scripting (XSS)](https://owasp.org/www-community/attacks/xss/)
	- Attackers can inject malicious scripts into webpages viewed by other users.
	- Ensuring that all variables go through validation and are then escaped or sanitized is known as perfect injection resistance.
	- Encoding: Encoding can [prevent XSS](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).

	<div style={{padding: '0 10px', background: '#edecec', borderRadius: '5px'}}>
		<span>&amp;</span> <span>&amp;amp;</span><br/>
		<span>&lt;</span> <span>&amp;lt;</span><br/>
		&gt; <span>&amp;gt;</span><br/>
		" <span>&amp;quot;</span><br/>
		' <span>&amp;#x27;</span><br/>
	</div>

	- Types:
		- Server: Server XSS occurs when untrusted user supplied data is included in an HTTP response
			generated by the server. The source of this data could be from the request, or from a stored
			location. As such, you can have both Reflected Server XSS and Stored Server XSS.
		- Client: Client XSS occurs when untrusted user supplied data is used to update the DOM with an
		unsafe JavaScript call. A JavaScript call is considered unsafe if it can be used to introduce
		valid JavaScript into the DOM. This source of this data could be from the DOM, or it could have been sent by the server
			(via an AJAX call, or a page load). The ultimate source of the data could have been from a
			request, or from a stored location on the client or the server. As such, you can have both
			Reflected Client XSS and Stored Client XSS.
- [Clickjacking](https://owasp.org/www-community/attacks/Clickjacking)
	- Attackers can trick users into clicking something different from what the user perceives.
	- They do it usually by loading an iframe with pre-filled data and using CSS or other mechanisms into
	fooling the user to click something they did not intend to.
- [Man-in-the-Middle (MitM) Attacks](https://owasp.org/www-community/attacks/Manipulator-in-the-middle_attack)
	- Attackers can intercept and possibly alter the communication between two parties.
	- The MITM attack could also be done over an https connection by using the same technique; the
	only difference consists in the establishment of two independent SSL sessions, one over each TCP
	connection. The browser sets a SSL connection with the attacker, and the attacker establishes
	another SSL connection with the web server. In general the browser warns the user that the digital
	certificate used is not valid, which can be ignored.
- [Cross-Site Request Forgery (CSRF)](https://owasp.org/www-community/attacks/csrf)
	- Cross-Site Request Forgery (CSRF) is an attack that forces an end user to execute unwanted
	actions on a web application in which they’re currently authenticated.
- [Credential Stuffing](https://owasp.org/www-community/attacks/Credential_stuffing)
	- Credential stuffing is the automated injection of stolen username and password pairs
	("credentials") in to website login forms, in order to fraudulently gain access to user accounts.
	- Since many users will re-use the same password and username/email, when those credentials are
	exposed (by a database breach or phishing attack, for example) submitting those sets of stolen
	credentials into dozens or hundreds of other sites can allow an attacker to compromise those
	accounts too.
- [Session Hijacking](https://owasp.org/www-community/attacks/Session_hijacking_attack)
	- Attackers steal a user’s session cookie to impersonate the victim in a web application.
-  Zero-Day Exploit
	- Attackers exploit a previously unknown vulnerability in the software or hardware before the developer releases a fix.
- Data Sniffing

### Headers
- [Content-Security-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP)
	- The Content Security Policy (CSP) header allows you to define which content sources are
	permissible and helps in preventing various types of content injection attacks, including
	Cross-site Scripting (XSS).
	- Directives:
		- `default-src`: The default policy for fetching resources (e.g., JavaScript, styles, images, etc.).
		- `script-src`: Defines valid sources for JavaScript.
		- `style-src`: Defines valid sources for stylesheets.
		- `img-src`: Defines valid sources for images.
		- `connect-src`: Defines valid sources for fetch, XMLHttpRequest, WebSocket, and EventSource connections.
		- `font-src`: Defines valid sources for fonts.
		- `object-src`: Defines valid sources for plugins (like \<object\>, \<embed\>, or \<applet\>).
		- `frame-src`: Defines valid sources for embedding resources using \<frame\> or \<iframe\>.
	- Values:
		- `self`: Allow content from the same domain.
		- `unsafe-inline`: Allow inline JavaScript and CSS. (Note: this is unsafe and diminishes the effectiveness of CSP).
		- `unsafe-eval`: Allow text-to-JavaScript mechanisms like eval. (Again, not recommended).
		- `https`: Allow content served over HTTPS from any domain.
		- `data`: Allow data URIs
	- Example:
		- `Content-Security-Policy: default-src 'self';`
		- `Content-Security-Policy: script-src 'self' https://apis.google.com; style-src https:; img-src 'self' https://images.example.com;`
		- `Content-Security-Policy: default-src 'self'; script-src 'self';`
	- Adding
		- Express:
			```js
			const express = require('express');
			const helmet = require('helmet');

			const app = express();

			app.use(helmet.contentSecurityPolicy({
				directives: {
					defaultSrc: ["'self'"],
					scriptSrc: ["'self'", "https://apis.google.com"],
					// Other directives...
				}
			}));
			```
		- Nginx
			- add_header Content-Security-Policy "default-src 'self';";
	- Misc:
		- Use `Content-Security-Policy-Report-Only` instead of `Content-Security-Policy` to log
		violations in the console without enforcing the policy. This is useful for testing.
		- CSP can be tricky to get right and can break functionality if improperly configured, so always
		test thoroughly, especially in development and staging environments, before applying policies to
		production. Always keep policies as restrictive as possible, only allowing sources that you
		absolutely need.
- [HTTPS Strict-Transport-Security (HSTS)](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security)
- [X-Frame-Options](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options)
	- The X-Frame-Options HTTP header is a security header that allows you to control whether your
	content can be embedded into other websites via \<iframe\>, \<object\>, \<embed\>, or \<frame\> elements.
	- This is important to prevent clickjacking attacks, where an attacker tricks a user into clicking
	something different from what the user perceives.
	- Values:
		- `DENY`: The page cannot be displayed in a frame, regardless of where the request came from.
		- `SAMEORIGIN`: The page can only be displayed in a frame on the same origin as the page itself.
		- `ALLOW-FROM uri`: The page can only be displayed in a frame on the specified origin (this
		directive is obsolete in modern browsers).
	- Implementation:
		- Express
		```js
		const express = require('express');
		const app = express();

		app.use((req, res, next) => {
				res.header('X-Frame-Options', 'DENY');
				next();
		});

		app.get('/', (req, res) => res.send('Hello, World!'));
		app.listen(3000);
		```
- X-Content-Type-Options
- Cookie Security Flags
	- Secure: Session cookies should be marked with the Secure attribute so that they are only communicated over HTTPS.
	- HttpOnly: Not accessible to JS
	- SameSite
	- Protect from XSS and CSRF

## Note: Miscellaneous
-	Origin and Host Headers in Requests
	- Host Header
		- Purpose: The "Host" header is used to specify the domain name of the server (for virtual
		hosting), and the TCP port number on which the server is listening.
		- Example: Imagine you want to reach a website hosted on "www.example.com" using the
		HTTP protocol (typically, port 80). A HTTP request to retrieve the homepage (root URL) might
		look like:
		```http
		http
		Copy code
		GET / HTTP/1.1
		Host: www.example.com
		```
		- In the case of HTTPS (SSL/TLS, typically port 443), browsers automatically send the correct
		port in the "Host" header.
	- Origin Header
		- Purpose: The "Origin" header is used to indicate where a fetch originates from. It doesn't
		include a path, but only the protocol, hostname, and port. This header is added by the web
		browser in cross-origin HTTP requests, and during HTTP request methods that may cause
		side-effects (like HTTP DELETE), to protect resources from malicious activity, like
		Cross-Site Request Forgery attacks.
		- Example: Imagine a scenario where a script on "https://www.attacker.com" is trying to make a
		request to "https://www.example.com/api/userdata" to fetch user data. The HTTP request from the
		browser at "attacker.com" might look like:
		```http
		GET /api/userdata HTTP/1.1
		Host: www.example.com
		Origin: https://www.attacker.com
		```
	- TLDR;
		- The Host is the domain the request is being sent to. This header was introduced so hosting sites
	could include multiple domains on a single IP.
		- The Origin header is the domain the request originates from.
	- "Host" is used by the browser to specify which internet host is being requested. CSP controls
	which hosts will be allowed in the browser.
	- "Origin" is used during CORS preflight to specify (and check against) the policy of the
	requested resource. If the target webserver doesn't allow requests from given origin, it fails it.
	It contains protocol, hostname and port - but no path.
	- Third-party Content: When working with hosts and origins in security headers, consider the case
	of third-party content.

- CORS vs CSP:
	- CORS is about controlling the access to resources from different origins. CORS is a protocol
	that requires cooperation between the server and the browser. CORS is strictly enforced by
	the browser, it is configured on the API side.
	- CSP is about controlling the loading and execution of content from different sources. CSP is a
	directive that is enforced by the browser.